---
title: "fibonacci"
date: 2019-12-02T18:35:00+09:00
lastmod: 2019-12-02T22:31:00+09:00
Math: true
tags: ["go", "golang", "memo", "algorthms", "dynamic programming", "recursion"]
author:
  given_name: Hideo
  family_name: Suzuki
  display_name: Hideo Suzuki
Summary: "フィボナッチ数の計算。本とかでふむふむと理解したつもりでしたが、実際に手を動かしてみる"
---

## Trigger

とある会社の仕事しようとエントリーしたらスキルテストが送付されてきまして

### Problem

nが正の整数のとき、以下を満たす関数があります。

$$
\begin{aligned}
  f(0)&=0 \\\\ 
  f(1)&=1 \\\\ 
  f(n)&=f(n-1)+f(n-2)
\end{aligned}
$$


1. \\(f(n)\\) を求めるプログラムを作成してください。（言語は得意なもので結構です。）


1. 作成したのプログラムを使って \\(f(8181)\\) を求めてください。


さて、解いてみましょう。

## TL;DR

- トップダウン式動的計画法とメモ化で計算量を \\(O(n)\\) に抑える

  - \\(fib(n)\\) の計算結果を単にキャッシュしておく

- uint64やfloat64だとオーバーフローしてしまうので、 任意精度の演算（大きな数値）の実装の [math/big](https://golang.org/pkg/math/big/) を使う


```go
package main

import (
        "fmt"
        "math/big"
)

func f(n int) *big.Int {
        var limit big.Int
        limit.Exp(big.NewInt(10), big.NewInt(99), nil)
        dp := make(map[int]*big.Int, n)

        return fib(n, dp)

}

func f(n int, dp map[int]*big.Int) *big.Int {

        if n == 0 {
                return big.NewInt(0)
        } else if n == 1 {
                return big.NewInt(1)
        }

        var ans big.Int
        if _, ok := dp[n]; !ok {
                ans.Add(f(n-1, dp), f(n-2, dp))
                dp[n] = &ans
        }
        return dp[n]
}

func main() {
        n := 8181
        fmt.Println(f(n))
}
```

```go
package main

import (
	"fmt"
	"math/big"
	"testing"
)

var ansS8181 = "239001090710360059034248200673803309562195124933438825088385870209105768309267224930066773271004303009695857056812050426322722227488483596969330539198412751609689113829755775066752844437629935556689908621747058520170917953833076673228939285877150494526386620300621280749499924952199516712960736433814553231958282333619656314497995824452475174641352224677997408976231194557854106641619031011172157654286916061043356523159334857136487352779804235483277506977454306460042287968212874761824582897118739286429568840003151050106146828835563160817912048376040050029809912293013734791567749471727392937824065261113177259783202662957881148637632338195187490758787735996699022778723575367214258563034452504094360966531897568256418608645465915444745840473934322871426418866598642747848660145342643755366760919516317387477526541252807114293921792114970905075434450564838742451198888345673434700068960962172644679947794329807611771708249033661865248799511661306285140477533559743999464574932871122125066107105911374614630965320293086278694399936369060752395531165804412176996135810584035128447884802662630006754418904791563798389799016017336123177492245220148295507234160487497059285034564989541608419857951981398972834439558266427410836592525389894745439937417033358839088886819050208294080514041113275997534122520735761635971975621605403703050984275628628811283403426936742851082726036123336764016240562071825096262121405587203818756266733130406345518134166312225673215071500009165695469591411166981267241101113735558997083171850461315680070428706983814819412637005375477590183910679020180492817106735246177201410250973608332090435177967936901320342366183865669056306257798108871942566285065496557591483743343454453933506"

var ans8181, _ = new(big.Int).SetString(ansS8181, 10)

var cases = []struct {
	id    int
	input int
	want  *big.Int
}{
	{id: 1, input: 0, want: big.NewInt(0)},
	{id: 2, input: 1, want: big.NewInt(1)},
	{id: 3, input: 2, want: big.NewInt(1)},
	{id: 4, input: 8181, want: ans8181},
}

func TestF(t *testing.T) {
	for _, tt := range cases {
		t.Run(fmt.Sprint(tt.id), func(t *testing.T) {
			got := f(tt.input)
			if got.Cmp(tt.want) != 0 {
				t.Errorf("%g, want: %g", got, tt.want)
			}
		})
	}
}

func Example_main() {
	main()

	// Output: 239001090710360059034248200673803309562195124933438825088385870209105768309267224930066773271004303009695857056812050426322722227488483596969330539198412751609689113829755775066752844437629935556689908621747058520170917953833076673228939285877150494526386620300621280749499924952199516712960736433814553231958282333619656314497995824452475174641352224677997408976231194557854106641619031011172157654286916061043356523159334857136487352779804235483277506977454306460042287968212874761824582897118739286429568840003151050106146828835563160817912048376040050029809912293013734791567749471727392937824065261113177259783202662957881148637632338195187490758787735996699022778723575367214258563034452504094360966531897568256418608645465915444745840473934322871426418866598642747848660145342643755366760919516317387477526541252807114293921792114970905075434450564838742451198888345673434700068960962172644679947794329807611771708249033661865248799511661306285140477533559743999464574932871122125066107105911374614630965320293086278694399936369060752395531165804412176996135810584035128447884802662630006754418904791563798389799016017336123177492245220148295507234160487497059285034564989541608419857951981398972834439558266427410836592525389894745439937417033358839088886819050208294080514041113275997534122520735761635971975621605403703050984275628628811283403426936742851082726036123336764016240562071825096262121405587203818756266733130406345518134166312225673215071500009165695469591411166981267241101113735558997083171850461315680070428706983814819412637005375477590183910679020180492817106735246177201410250973608332090435177967936901320342366183865669056306257798108871942566285065496557591483743343454453933506

}

func BenchmarkF(b *testing.B) {
	for i := 0; i < b.N; i++ {
		f(i)
	}
}
```


## Process

**言語は得意なもので結構です。** との事ですので、最近書き続けているGoで書きます。

### recursion

問題にある関数をそのままコーディング。

https://play.golang.org/p/qXsDDWiHTHd

小さい数なら問題ありませんが、\\(n = 100\\) でダメ。 \\(8181\\) は遠い。

https://play.golang.org/p/5pZIZxJexVw

### dynamic programming

同じ計算を再度繰り返すのはコストがかかるので、計算結果をキャッシュしておいて再利用する動的計画法とメモ化を使います。 [^1]

https://play.golang.org/p/GmupThQeo_V

**Program exited: process took too long.** は出なくなりましたが、負の値が出ています。明らかにおかしいです。

### float64

オーバーフローしているので、float64を使います。

https://play.golang.org/p/I1w2ZfDa55X

実行結果は、**+Inf** : 正の無限大となり数値が出せません。


### uint64

何を血迷ったか、uint64なら上手くいくかな思って試しました。

https://play.golang.org/p/-S4owe9Q-kM

正の整数が出ていますが、果たしてこの値は正しいのでしょうか。

そう思い、フィボナッチ数を計算できるサイト [フィボナッチ数 - 高精度計算サイト](https://keisan.casio.jp/exec/system/1161228773) を見つけ、計算した結果、明らかに値が違います。

やはり血迷ってました。

### math/big

任意精度の演算（大きな数値）の実装の [math/big](https://golang.org/pkg/math/big/) を利用します。

このパッケージのドキュメントに [Example(Fibonacci)](https://golang.org/pkg/math/big/#example__fibonacci) があったので参考にします。

https://play.golang.org/p/oAEmcTRqCFv

良さげです。計算結果も、[フィボナッチ数 - 高精度計算サイト](https://keisan.casio.jp/exec/system/1161228773) の結果と同じ感じです。

## SeeAlso

- [世界で闘うプログラミング力を鍛える本 ~コーディング面接189問とその解法~](https://www.amazon.co.jp/dp/4839960100/ref=cm_sw_em_r_mt_dp_U_USo5Db4M1J5P3)
- [フィボナッチ数 - 高精度計算サイト](https://keisan.casio.jp/exec/system/1161228773)
- [Big Integers in Go language: a developer’s Reference for Printing, Converting and Serializing](https://medium.com/orbs-network/big-integers-in-go-14534d0e490d)


[^1]: トップダウンの動的計画法を *メモ化* 、ボトムアップの処理のみの場合に *動的計画法* と呼ぶ人もいるそうですが、参考にした [世界で闘うプログラミング力を鍛える本 ~コーディング面接189問とその解法~](https://www.amazon.co.jp/dp/4839960100/ref=cm_sw_em_r_mt_dp_U_USo5Db4M1J5P3) では、区別せず、動的計画法と呼ぶ事にしますと用語メモに注釈されていましたのでその用語のまま使っています
